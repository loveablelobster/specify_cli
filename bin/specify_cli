#!/usr/bin/env ruby
# frozen_string_literal: true

require 'gli'
require 'specify'

include GLI::App

program_desc Specify::DESCRIPTION

version Specify::VERSION

subcommand_option_handling :normal
arguments :strict

sessions = []
script_dir = Dir.pwd

desc 'Connect to host.'
arg_name '[name]'
default_value 'localhost'
flag %i[H host]

desc 'Port number to use for connection.'
arg_name '[number]'
default_value '3306'
flag %i[p port]

desc 'MySQL/MariaDB user for login.'
arg_name '[name]'
flag %i[u user]

desc 'Password to use when connecting to server. Omit for password prompt.'
arg_name '[name]'
flag %i[P password]

desc 'Database to use.'
arg_name '[name]'
flag %i[D database]

desc 'Specify User used for the session.'
arg_name '[name]'
flag %i[U specify_user]

desc 'YAML File with settings for database connections and directory mappings.'
arg_name '[path]'
default_value File.expand_path('~/.specify_dbs.rc.yaml')
flag %i[c db_config]

desc 'Add a database configuration.'
long_desc <<~HEREDOC
  The database configuration file ~/.specify_dbs.rc.yaml contains a 'hosts'
  section with information about the Specify databases by host (host name, port,
  database name, MySQL/MariaDB user name and password, Specify user name). Add
  information to work with a specific database using this command. Use the global
  options to specify host, port, MySQL/MariaDB user name and password, and
  Specify user name.\n
  The example below configures the database 'specify' on 'specify.example.org'
  with the MySQL/MariaDB user 'root' (the password is not given, so when a
  command is executed the user will be prompted; add the -p global option to
  also store the password):\n
  specify_cli -H specify.example.org -u root -U specifyuser database specify
HEREDOC
arg_name '[database]'
command [:database, :d] do |c|
  c.action do |global_options, options, args|
    host = global_options[:host]
    database = args.shift

    file = File.expand_path(global_options[:db_config])

    Specify::CLI.db_config! file, global_options

    db_config = Specify::Configuration::DBConfig.new host, database, file

    if db_config.known?
      STDERR.puts "#{database} on #{host} is already configured"
      exit 0
    else
      unless db_config.host?
        exit 1 unless Specify::CLI.configure_host(db_config)
      end
      Specify::CLI.configure_database db_config
    end
  end
end

desc 'Map a git repository to a host for automatic target resolution.'
long_desc <<~HEREDOC
  The viewset command can automatically resolve targets (database, discipline,
  collection, user type, user) based on branch names in a Git repository. To
  allow working with multiple databases on different hosts, a repository needs
  to be mapped to a host name. This is done by mapping the full path name of
  the directory containing the Git repository to a host name. The repository
  command will add such a mapping to the 'dir_names' section of the database
  configuration file ~/.specify_dbs.rc.yaml. Use the global option --host to
  specify the host name.\n
  The example below maps a repository in '~/specify_forms/invertpaleo' to the
  host 'specify.example.org':\n
  specify_cli -H specify.example.org repository ~/specify_forms/invertpaleo
HEREDOC
arg_name '[repository_name]'
command [:repository, :r] do |c|
  c.desc 'Map the current directory/repository to the host'
  c.switch %i[c current]

  c.action do |global_options, options, args|
    host = global_options[:host]
    dir = options[:current] ? Dir.pwd : File.expand_path(args.shift)

    file = File.expand_path(global_options[:db_config])

    Specify::CLI.db_config! file, global_options

    host_config = Specify::Configuration::HostConfig.new file

    unless host_config.directory? dir
      host_config.map_directory dir, host
      host_config.save
    end
  end
end

desc 'Create stub records'
long_desc <<~HEREDOC
  The stubs command creates stub records in a collection, so that catalog
  numbers can be printed to labels e.g. prior to mass digitizaton. The command
  currently only works for collection objects, and will currently only work for
  collections using a numeric catalog numbering scheme.\n
  Generated catalog numbers are printed to stdout.\n
  The number of stub records created is specified with the [count] argument.
  The target collection is provided as the [collection] argument. Host and
  database are provided using the global options --host and --database
  respectively.
  The command will generate a record set with all generated collection objects.
  The record set will be owned by either the Specify user (as provided via the
  global option --specify_user or in the database configuration file), or the
  specify user provided with the --cataloger option. If no dataset name is
  provided using the --dataset option, the default name will be 'stub record set
  <TIMESTAMP>'.\n
  Records can be created with the following basic information (provided using
  the command options): cataloger, accession, geography/locality, taxon,
  preparation.\n
  Only existing accessions and preparation types can be assigned at present.\n
  If geographic information is provided, but no locality name, the
  default locality name will be 'not cataloged, see label'. This can be changed
  using the --locality option. Geographic information should be passed in the
  format 'Geographic Rank: Name; Geographic Subrank: Name; locality: name' where
  locality is optional (if not given, the default locality name will be used)
  (example: 'Country: United States, State: Kansas, County: Douglas County;
  locality: Downtown Lawrence'). Only geographic names/ranks and locality names
  that exist in the database will be accepted.\n
  Taxon information is assigned as a determination. Only one determination can
  be given to the stub records using the command. Taxon information is provided
  in the format 'Taxon Rank: Name; Taxon Subrank: Name' (example: 'Phylum:
  Arthropoda; Class: Trilobita; Order: Asaphida; Family: Asaphidae'). Only
  taxonomic names that exist in the database will be accepted.\n
  Alternatively to using the options, a YAML file with all required information
  can be passed with the --file option. In that case, the [database] and
  [collection] arguments can be ommitted.
HEREDOC
arg_name '[collection] [count]'
command [:stubs, :s] do |c|
  c.desc 'Load stub record information from a YAML file.'
  c.arg_name '[yaml_file]'
  c.flag %i[f file]

  c.desc 'Specify user appearing as cataloger and owner of the record set.'
  c.arg_name '[name]'
  c.flag %i[c cataloger]

  c.desc 'Name of the datas set (record set) generated.'
  c.arg_name '[name]'
  c.flag %i[d dataset]

  c.desc 'Accession number for the accession to which the stub records belong.'
  c.arg_name '[accession_number]'
  c.flag %i[a accession]

  c.desc 'Geographic and locality information for the stub records.'
  c.arg_name '[geography]'
  c.flag %i[g geography]

  c.desc 'Default locality name if geographic information has no locality.'
  c.arg_name '[name]'
  c.flag %i[l locality]

  c.desc 'Taxon to which stub records are determined.'
  c.arg_name 'taxon'
  c.flag %i[t taxon]

  c.desc 'Preparation type for the stub records, if they have preparations.'
  c.arg_name '[name]'
  c.flag %i[p preptype]

  c.desc 'Number of preparation items (requires --preptype to be set).'
  c.arg_name '[number]'
  c.flag %i[n prepcount]

  c.action do |global_options, options, args|
    count = args.pop.to_i
    params = if options[:file]
               file = File.expand_path(options[:file])
               Psych.load_file(file)
             else
               Specify::CLI.wrap_args(global_options, args, options.compact)
             end

    stub_generator = Specify::Service::StubGenerator.unwrap params

    sessions << stub_generator.session

    Specify::CLI.make_stubs stub_generator, count
  end
end

desc 'Upload a view to the database.'
long_desc <<~HEREDOC
  The viewset command uploads a view definition file (.views.xml) to the
  database. Viewset can be uploaded to either of the following levels:
  discipline, collection, user type, user. Use the -c or -d switches to upload
  to collection or discipline respectively. To upload for a specific user level,
  use the --user_type command option and provide the user type name ('manager',
  'fullaccess', 'limitedaccess', or 'guest'). To upload to user level, use the
  --user command option and provide the Specify user name.\n
  The [collection] argument is required unless the -b or -B command options are
  used (the collection is needed to register a login session).\n
  Provide information about the host, database, MySQL/MariaDB user and Specify
  user with the global options.
  The --branch command option allows to specify a branch name in the format
  'repository_name/database_name/collection_name/level', from which all
  necessary information about the target (host, database, collection, level) can
  be parsed. This requires that the directory containing the view definition
  file ([file] argument) is mapped to a host. If your present working directory
  is mapped to a host and contains a Git repository and the current branch
  conforms to the naming convention
  'repository_name/database_name/collection_name/level', use the -b switch to
  use th current branch instead of specifying the branch name with --branch.
HEREDOC
arg_name '[collection] [file]'
command [:viewset, :vs] do |c|
  c.desc 'Use current branch to resolve target.'
  c.switch :b

  c.desc 'Resolve target from branch name.'
  c.arg_name '[name]'
  c.flag %i[B branch]

  c.desc 'Upload to collection level.'
  c.switch :c

  c.desc 'Upload to discipline level.'
  c.switch :d

  c.desc 'Upload to specific user type [name] in the collection.'
  c.arg_name '[name]'
  c.flag %i[t user_type]

  c.desc 'Upload to specify user [name] in the collection.'
  c.arg_name '[name]'
  c.flag %i[u user]

  c.action do |global_options, options, args|
    file = File.expand_path(args.pop)
    collection = args.shift
    config = global_options[:db_config]
    params = { host: global_options[:host],
               database: global_options[:database],
               collection: collection,
               specify_user: global_options[:specify_user],
               config: config }

    view_loader = if options[:b] || options[:B]
                    path = File.dirname(File.expand_path(file))
                    Dir.chdir path unless script_dir == path
                    Specify::Service::ViewLoader.from_branch path: path,
                                                             name: options[:B],
                                                             config: config
                  else
                    raise 'collection required' unless collection
                    params[:level] = Specify::CLI.level options
                    Specify::Service::ViewLoader.new params
                  end
    sessions << view_loader.session
    view_loader.import file
  end
end

pre do |global, command, options, args|
  # Pre logic here
  # Return true to proceed; false to abort and not call the
  # chosen command
  # Use skips_pre before a command to skip this block
  # on that command only
  true
end

post do |global, command, options, args|
  # Post logic here
  # Use skips_post before a command to skip this
  # block on that command only
  sessions.each(&:close)
  Dir.chdir script_dir unless script_dir == Dir.pwd
end

on_error do |exception|
  # Error logic here
  # return false to skip default error handling

  sessions.each(&:close)
  Dir.chdir script_dir unless script_dir == Dir.pwd
  true
end

exit run(ARGV)
